local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "HM HUB",
    LoadingTitle = "Loading HM HUB",
    LoadingSubtitle = "by The Hollows",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,           -- nil = default folder
        FileName = "HM Hub"
    },
    KeySystem = false
})

task.wait(0.1)
local MainTab = Window:CreateTab("Player", nil) 

-- Variables
local autoClick = false
local autoStat = false
local selectedStat = "Energy"  -- Default

-- Auto Clicker Toggle
local ClickToggle = MainTab:CreateToggle({
    Name = "Auto Clicker",
    CurrentValue = false,
    Flag = "AutoClickToggle",
    
    Callback = function(Value)
        autoClick = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Clicker",
                Content = "Clicking every ~0.03s...",
                Duration = 3
            })
            
            task.spawn(function()
                while autoClick do
                    pcall(function()
                        local clickRemote = game:GetService("ReplicatedStorage")
                            :WaitForChild("Packages")
                            :WaitForChild("_Index")
                            :WaitForChild("sleitnick_knit@1.5.1")
                            :WaitForChild("knit")
                            :WaitForChild("Services")
                            :WaitForChild("ClickService")
                            :WaitForChild("RF")
                            :WaitForChild("Click")
                        
                        clickRemote:InvokeServer()
                    end)
                    
                    task.wait(0.1)
                end
            end)
        end
    end,
})


local AutoRankUpToggle = MainTab:CreateToggle({
    Name = "Auto Rank Up",
    CurrentValue = false,
    Flag = "AutoRankUp",
    
    Callback = function(Value)
        getgenv().AutoRankUp = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Rank Up",
                Content = "Ranking up every 60s...",
                Duration = 4
            })
            
            task.spawn(function()
                while getgenv().AutoRankUp do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Packages")
                            :WaitForChild("_Index")
                            :WaitForChild("sleitnick_knit@1.5.1")
                            :WaitForChild("knit")
                            :WaitForChild("Services")
                            :WaitForChild("RankupService")
                            :WaitForChild("RF")
                            :WaitForChild("RankUp")
                            :InvokeServer()
                    end)
                    
                    if not success then
                        warn("Auto Rank Up error: " .. tostring(err))
                        Rayfield:Notify({
                            Title = "Auto Rank Up Error",
                            Content = "Failed to rank up â€“ check console. Stopping...",
                            Duration = 6
                        })
                        getgenv().AutoRankUp = false
                        break
                    end
                    
                    task.wait(60)
                end
            end)
        else
            Rayfield:Notify({
                Title = "Auto Rank Up",
                Content = "Stopped.",
                Duration = 3
            })
        end
    end,
})


task.wait(1)
local MiscTab = Window:CreateTab("Game", nil)   

local rerollTypes = {
    "Saiyan",
    "Dragon",
    "Chakra",
    "Jinchuriki",
    "Haki",
    "Devil Fruit",
    "Reiatsu",
    "Voltstanding",
    "Breathing",
    "Curse",
    "Cursed Technique",
    "Weapons",
    "Demon Art"   -- â† added here
}

-- Dropdown (single selection)
local selectedReroll = "Saiyan"  -- default

local RerollDropdown = MiscTab:CreateDropdown({
    Name = "Select Reroll Type",
    Options = rerollTypes,
    CurrentOption = {"Saiyan"},
    MultipleOptions = false,
    Flag = "RerollType",
    Callback = function(option)
        selectedReroll = option[1]
        Rayfield:Notify({
            Title = "Reroll Updated",
            Content = "Now set to: " .. selectedReroll,
            Duration = 3.5,
            Image = 4483362458
        })
    end,
})

-- Toggle for auto-reroll loop
local autoRerollEnabled = false

MiscTab:CreateToggle({
    Name = "Auto Reroll",
    CurrentValue = false,
    Flag = "AutoReroll",
    Callback = function(Value)
        autoRerollEnabled = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Reroll Started",
                Content = "Rerolling " .. selectedReroll .. " every ~4â€“5.5s",
                Duration = 4
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RerollRF = nil
                local WeaponRollRF = nil
                
                -- Cache both possible remotes safely
                pcall(function()
                    RerollRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("RerollableService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("Reroll", 8)
                end)
                
                pcall(function()
                    WeaponRollRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("WeaponService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("Roll", 8)
                end)
                
                -- If neither remote was found â†’ stop
                if not RerollRF and not WeaponRollRF then
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "No reroll remote found (RerollableService or WeaponService).",
                        Duration = 6
                    })
                    autoRerollEnabled = false
                    return
                end
                
                while autoRerollEnabled do
                    local success, result
                    
                    if selectedReroll == "Weapons" then
                        -- Weapons â†’ special remote + fixed arg
                        if not WeaponRollRF then
                            Rayfield:Notify({Title = "Error", Content = "Weapon Roll remote missing", Duration = 5})
                            autoRerollEnabled = false
                            break
                        end
                        
                        success, result = pcall(function()
                            return WeaponRollRF:InvokeServer("SwordsI")
                        end)
                    else
                        -- All other types (including "Demon Art") â†’ standard reroll remote
                        if not RerollRF then
                            Rayfield:Notify({Title = "Error", Content = "RerollableService remote missing", Duration = 5})
                            autoRerollEnabled = false
                            break
                        end
                        
                        local args = { selectedReroll }
                        success, result = pcall(function()
                            return RerollRF:InvokeServer(unpack(args))
                        end)
                    end
                    
                    if success then
                        print("Reroll success for " .. selectedReroll .. " â†’ " .. tostring(result))
                    else
                        warn("Reroll failed for " .. selectedReroll .. ": " .. tostring(result))
                    end
                    
                    -- Delay: ~3.5â€“5.5 seconds (randomized)
                    task.wait(3.5 + math.random() * 2)
                end
                
                Rayfield:Notify({
                    Title = "Auto Reroll Stopped",
                    Content = "Loop paused.",
                    Duration = 3
                })
            end)
        else
            Rayfield:Notify({
                Title = "Auto Reroll Stopped",
                Content = "Loop paused.",
                Duration = 3
            })
        end
    end,
})

-- =====================================
-- Machines Dropdown with AUTO-TELEPORT on Selection
-- =====================================

local machinesFolder = workspace:WaitForChild("Machines")
local player = game.Players.LocalPlayer

local function getMachineNames()
    local names = {}
    local seen = {}

    for _, child in ipairs(machinesFolder:GetChildren()) do
        local name = child.Name
        if name and not seen[name] then
            seen[name] = true
            table.insert(names, name)
        end
    end

    table.sort(names)
    
    if #names == 0 then
        table.insert(names, "No machines found")
    end
    
    return names
end

-- Dropdown - Teleports instantly on selection
local MachinesDropdown = MiscTab:CreateDropdown({
    Name = "Select Machine (Auto-TP)",
    Options = getMachineNames(),
    CurrentOption = {"None"},
    MultipleOptions = false,
    Flag = "MachineTPDropdown",
    
    Callback = function(Option)
        local selectedMachine = Option and Option[1]  -- Extract string
        
        if not selectedMachine or selectedMachine == "No machines found" or selectedMachine == "None" then
            return  -- Do nothing if invalid
        end
        
        -- Notify selection
        Rayfield:Notify({
            Title = "Teleporting...",
            Content = "Moving to: " .. selectedMachine,
            Duration = 1
        })
        print("Auto-TP to machine:", selectedMachine)
        
        -- Find the machine
        local machine = machinesFolder:FindFirstChild(selectedMachine)
        if not machine then
            Rayfield:Notify({
                Title = "Error",
                Content = selectedMachine .. " not found",
                Duration = 1
            })
            return
        end
        
        -- Get HRP from workspace.Players
        local playerFolder = workspace:FindFirstChild("Players")
        if not playerFolder then
            Rayfield:Notify({Title = "Error", Content = "Players folder not found", Duration = 4})
            return
        end
        
        local playerChar = playerFolder:FindFirstChild(player.Name)
        if not playerChar then
            Rayfield:Notify({Title = "Error", Content = "Your character not found", Duration = 4})
            return
        end
        
        local hrp = playerChar:FindFirstChild("HumanoidRootPart")
        if not hrp then
            Rayfield:Notify({Title = "Error", Content = "No HumanoidRootPart found", Duration = 4})
            return
        end
        
        -- Get target CFrame (handles Parts/Models)
        local targetCFrame
        if machine.PrimaryPart then
            targetCFrame = machine.PrimaryPart.CFrame
        elseif machine:IsA("BasePart") then
            targetCFrame = machine.CFrame
        else
            local firstPart = machine:FindFirstChildWhichIsA("BasePart", true)
            targetCFrame = firstPart and firstPart.CFrame or CFrame.new(machine.Position or Vector3.new())
        end
        
        -- Teleport 5 studs above
        local success, err = pcall(function()
            hrp.CFrame = targetCFrame + Vector3.new(0, 5, 0)
        end)
        
        if success then
            print("Auto-teleported to:", selectedMachine)
        else
            warn("TP failed:", tostring(err))
            Rayfield:Notify({
                Title = "Teleport Failed",
                Content = "Check console for error",
                Duration = 1
            })
        end
    end,
})

-- Optional: Refresh button (still useful)
MiscTab:CreateButton({
    Name = "Refresh Machines List",
    Callback = function()
        local newOptions = getMachineNames()
        MachinesDropdown:Refresh(newOptions, true)
        MachinesDropdown:Set({"None"})
        Rayfield:Notify({
            Title = "Refreshed",
            Content = #newOptions .. " machines found",
            Duration = 1
        })
    end,
})


-- =====================================
-- AUTO FARM - Detects current map from workspace.Maps + Mobs from MobSpawns
-- Dropdown shows only mobs on your current island
-- =====================================
task.wait(0.5)
local FarmTab = Window:CreateTab("Auto Farm", 4483362458)

-- LocalScript (Rayfield UI - Farming Tab)

local player = game.Players.LocalPlayer
local workspace = game.Workspace

local mapsFolder    = workspace:WaitForChild("Maps")
local mobSpawnsFolder = workspace:WaitForChild("MobSpawns")

local selectedMobTypes = {}     -- table of selected mob names/types
local currentTarget    = nil    -- {obj, dist, mobType, root}

local currentMapFolder = nil
local currentMobFolder = nil

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Map Detection & Mob Type Collection
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function detectCurrentMap()
    local character = player.Character
    if not character then return nil end

    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local playerPos = root.Position
    local closestMapName = nil
    local minAvgDist = math.huge

    for _, mapFolder in mapsFolder:GetChildren() do
        if mapFolder:IsA("Folder") or mapFolder:IsA("Model") then
            local mapName = mapFolder.Name
            local mobFolder = mobSpawnsFolder:FindFirstChild(mapName)

            if mobFolder and #mobFolder:GetChildren() > 0 then
                local totalDist = 0
                local count = 0

                for _, mob in mobFolder:GetChildren() do
                    local mobRoot = (mob:IsA("Model") and mob:FindFirstChild("HumanoidRootPart")) or (mob:IsA("BasePart") and mob)
                    if mobRoot then
                        totalDist += (playerPos - mobRoot.Position).Magnitude
                        count += 1
                    end
                end

                if count > 0 then
                    local avgDist = totalDist / count
                    if avgDist < minAvgDist then
                        minAvgDist = avgDist
                        closestMapName = mapName
                        currentMapFolder = mapFolder
                        currentMobFolder = mobFolder
                    end
                end
            end
        end
    end

    return closestMapName
end

local function getMobTypes()
    if not currentMobFolder then
        return {"Scan map first"}
    end

    local types = {}
    local seen = {}

    for _, child in currentMobFolder:GetChildren() do
        local mobType

        -- Prefer attribute if present (more reliable in many games)
        if child:GetAttribute("Name") then
            mobType = tostring(child:GetAttribute("Name"))
        else
            -- Fallback: clean object name
            mobType = child.Name
                :gsub("_%d+$", "")
                :gsub("Clone", "")
                :match("^%s*(.-)%s*$")
        end

        if mobType and #mobType > 0 and not seen[mobType] then
            seen[mobType] = true
            table.insert(types, mobType)
        end
    end

    table.sort(types)
    return #types > 0 and types or {"No mobs found on this map"}
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Alive Check (stronger version from enemy code)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function isMobAlive(target)
    local part = target:IsA("Model") and target:FindFirstChildWhichIsA("BasePart", true) or target
    if not part or not part.Parent then return false end

    -- UUID check (common despawn indicator)
    if part:GetAttribute("UUID") == nil then return false end

    -- Explicit Dead flag
    if part:GetAttribute("Dead") == true then return false end

    -- Health attribute
    local health = part:GetAttribute("Health")
    if health ~= nil and health <= 0 then return false end

    -- Optional Humanoid fallback
    local humanoid = target:FindFirstChildOfClass("Humanoid") or part.Parent:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return false end

    return true
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Get alive mobs from selected types, sorted by distance
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function getAliveMobs()
    if #selectedMobTypes == 0 or (#selectedMobTypes == 1 and selectedMobTypes[1] == "None") then
        return {}
    end

    if not currentMobFolder then return {} end

    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return {} end

    local allowed = {}
    for _, t in selectedMobTypes do
        if t ~= "None" and t ~= "Scan map first" and t ~= "No mobs found on this map" then
            allowed[t] = true
        end
    end

    local aliveList = {}
    for _, obj in currentMobFolder:GetChildren() do
        local mobType = obj:GetAttribute("Name") or
            obj.Name:gsub("_%d+$", ""):gsub("Clone", ""):match("^%s*(.-)%s*$")

        if mobType and allowed[mobType] and isMobAlive(obj) then
            local rootPart = (obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart")) or
                             (obj:IsA("BasePart") and obj)

            if rootPart then
                local dist = (hrp.Position - rootPart.Position).Magnitude
                table.insert(aliveList, {
                    obj     = obj,
                    root    = rootPart,
                    dist    = dist,
                    mobType = mobType
                })
            end
        end
    end

    table.sort(aliveList, function(a,b) return a.dist < b.dist end)
    return aliveList
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Teleport helper
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function teleportToMob(hrp, mobData)
    if not hrp or not mobData or not mobData.root then return false end
    if not isMobAlive(mobData.obj) then return false end

    local offset = CFrame.new(0, 3, -5)   -- behind + above; adjust to taste
    hrp.CFrame = mobData.root.CFrame * offset
    return true
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI Elements (on your FarmTab or main Tab)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local MobDropdown = FarmTab:CreateDropdown({
    Name = "Select Mobs to Farm",
    Options = {"Scan map first"},
    CurrentOption = {"Scan map first"},
    MultipleOptions = true,
    Flag = "MobFarmSelector",

    Callback = function(selected)
        selectedMobTypes = selected
        if #selected == 0 or (#selected == 1 and (selected[1] == "None" or selected[1] == "Scan map first")) then
            currentTarget = nil
        end
    end,
})

FarmTab:CreateButton({
    Name = "ğŸ” Scan Current Map & Refresh Mobs",
    Callback = function()
        currentMapFolder = nil
        currentMobFolder = nil

        local mapName = detectCurrentMap()

        if mapName then
            local mobCount = currentMobFolder and #currentMobFolder:GetChildren() or 0
            local types = getMobTypes()
            local typesCount = #types > 0 and (#types == 1 and types[1] == "No mobs found on this map" and 0 or #types) or 0

            Rayfield:Notify({
                Title = "Map Detected",
                Content = mapName .. " (" .. mobCount .. " mobs, " .. typesCount .. " types)",
                Duration = 5
            })

            MobDropdown:Refresh(types, true)
        else
            Rayfield:Notify({
                Title = "No Map / Mobs Detected",
                Content = "Move closer to a mob spawn area",
                Duration = 6
            })
            MobDropdown:Refresh({"Scan map first"}, true)
        end
    end,
})

FarmTab:CreateToggle({
    Name = "Auto Farm Cloest",
    CurrentValue = false,
    Flag = "AutoMobFarm",

    Callback = function(enabled)
        getgenv().AutoMobFarm = enabled

        if enabled then
            task.spawn(function()
                while getgenv().AutoMobFarm do
                    task.wait(0.2)

                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if not hrp then continue end

                    local aliveMobs = getAliveMobs()
                    if #aliveMobs == 0 then
                        currentTarget = nil
                        task.wait(0.8)
                        continue
                    end

                    -- Validate/update current target
                    if currentTarget and currentTarget.obj then
                        local stillAlive = false
                        for _, mob in aliveMobs do
                            if mob.obj == currentTarget.obj then
                                currentTarget = mob
                                stillAlive = true
                                break
                            end
                        end
                        if not stillAlive then
                            currentTarget = nil
                        end
                    end

                    -- Pick closest if none or invalid
                    if not currentTarget then
                        currentTarget = aliveMobs[1]
                        print("Targeting â†’", currentTarget.mobType, math.floor(currentTarget.dist), "studs")
                    end

                    if not isMobAlive(currentTarget.obj) then
                        currentTarget = nil
                        continue
                    end

                    currentTarget.dist = (hrp.Position - currentTarget.root.Position).Magnitude

                    if currentTarget.dist > 7 then
                        teleportToMob(hrp, currentTarget)
                        task.wait(0.25)
                    else
                        task.wait(0.35)  -- already in range
                    end
                end
                currentTarget = nil
            end)
        else
            currentTarget = nil
        end
    end,
})

-- Auto Stat Upgrade (every 60 seconds) - Add this after your MainTab is created

local stats = {
    "Energy",
    "Gems",
    "Luck",
    "Damage"
}

local selectedStat = "Energy"   -- default
local autoUpgradeEnabled = false
local UPGRADE_DELAY = 60        -- fixed 1 minute

-- Dropdown for stat selection
local StatDropdown = MainTab:CreateDropdown({
    Name = "Select Stat to Upgrade",
    Options = stats,
    CurrentOption = {"Energy"},
    MultipleOptions = false,
    Flag = "AutoStatType",
    Callback = function(option)
        selectedStat = option[1]
        Rayfield:Notify({
            Title = "Stat Updated",
            Content = "Now auto-upgrading: " .. selectedStat,
            Duration = 4
        })
    end,
})

-- Toggle for auto-upgrade loop (every 60 seconds)
MainTab:CreateToggle({
    Name = "Auto Upgrade Stat",
    CurrentValue = false,
    Flag = "AutoStatUpgrade",
    Callback = function(enabled)
        autoUpgradeEnabled = enabled
        
        if enabled then
            Rayfield:Notify({
                Title = "Auto Upgrade Started",
                Content = "Upgrading " .. selectedStat .. " every 60 seconds",
                Duration = 5
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local PutStatRF
                
                -- Safely get the RemoteFunction
                local pathSuccess, pathErr = pcall(function()
                    PutStatRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("LevelService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("PutStat", 8)
                end)
                
                if not pathSuccess or not PutStatRF then
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Could not find PutStat Remote.\nPath might have changed.",
                        Duration = 7
                    })
                    autoUpgradeEnabled = false
                    return
                end
                
                while autoUpgradeEnabled do
                    local success, result = pcall(function()
                        return PutStatRF:InvokeServer(selectedStat, 1)
                    end)
                    
                    if success then
                        print("[AutoStat] Upgraded " .. selectedStat .. " +1 â†’ " .. tostring(result))
                    else
                        warn("[AutoStat] Failed: " .. tostring(result))
                        Rayfield:Notify({
                            Title = "Upgrade Failed",
                            Content = "Error during stat upgrade. Check console.",
                            Duration = 6
                        })
                    end
                    
                    task.wait(UPGRADE_DELAY)  -- exactly 60 seconds
                end
                
                Rayfield:Notify({
                    Title = "Auto Upgrade Stopped",
                    Content = "No more upgrades for " .. selectedStat,
                    Duration = 3
                })
            end)
        else
            Rayfield:Notify({
                Title = "Auto Upgrade Stopped",
                Content = "Loop paused.",
                Duration = 3
            })
        end
    end,
})

task.wait(0.6)
local RealMiscTab = Window:CreateTab("Misc", nil)



-- Combined Grind Selector + Auto-Farm Toggle
-- Now supports: Boss Rush, Raid, Time Trial, Demon Defense

-- Shared variables
local selectedGrindItem = "Boss Rush I"   -- default
local autoGrindEnabled = false
local FARM_DELAY = 60                    -- 10 minutes (as you set)

-- All options in one dropdown
local grindOptions = {
    "Boss Rush I",
    "Boss Rush II",
    "Raid - Normal",
    "Raid - Medium",
    "Raid - Hard",
    "Time Trial - Easy",
    "Time Trial - Medium",
    "Time Trial - Hard",
    "Demon Defense - Normal",
    "Demon Defense - Medium",
    "Demon Defense - Hard"
}

-- Dropdown: choose what to auto-farm
MiscTab:CreateDropdown({
    Name = "Select What to Grind",
    Options = grindOptions,
    CurrentOption = {"Boss Rush I"},
    MultipleOptions = false,
    Flag = "GrindSelector",
    Callback = function(option)
        selectedGrindItem = option[1]
        Rayfield:Notify({
            Title = "Grind Target Updated",
            Content = "Now set to: " .. selectedGrindItem,
            Duration = 4
        })
    end,
})

-- Toggle: auto-farm whatever is currently selected
MiscTab:CreateToggle({
    Name = "Auto Grind Selected Mode",
    CurrentValue = false,
    Flag = "AutoGrindToggle",
    Callback = function(enabled)
        autoGrindEnabled = enabled
        
        if enabled then
            Rayfield:Notify({
                Title = "Auto Grind Started",
                Content = selectedGrindItem .. " every ~" .. FARM_DELAY .. "s",
                Duration = 5
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local StarterGui = game:GetService("StarterGui")
                
                local BossRushRF = nil
                local RaidRF = nil
                local TrialRF = nil
                local DefenseRF = nil
                
                -- Cache all possible remotes safely
                pcall(function()
                    BossRushRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("BossRushService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("StartBossRush", 8)
                end)
                
                pcall(function()
                    RaidRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("ProgressionRaidService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("StartRaid", 8)
                end)
                
                pcall(function()
                    TrialRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("TimeTrialService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("JoinTrial", 8)
                end)
                
                pcall(function()
                    DefenseRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("DemonDefenseService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("StartDefense", 8)
                end)
                
                while autoGrindEnabled do
                    local success, result
                    
                    if selectedGrindItem:find("Boss Rush") then
                        -- Boss Rush (always fires)
                        if not BossRushRF then
                            Rayfield:Notify({Title = "Error", Content = "BossRush remote missing", Duration = 6})
                            autoGrindEnabled = false
                            break
                        end
                        
                        local arg = (selectedGrindItem == "Boss Rush I") and "I" or "II"
                        success, result = pcall(function()
                            return BossRushRF:InvokeServer(arg)
                        end)
                    elseif selectedGrindItem:find("Raid") then
                        -- Raid (always fires)
                        if not RaidRF then
                            Rayfield:Notify({Title = "Error", Content = "Raid remote missing", Duration = 6})
                            autoGrindEnabled = false
                            break
                        end
                        
                        local difficulty = selectedGrindItem:match("Raid %- (%w+)") or "Normal"
                        success, result = pcall(function()
                            return RaidRF:InvokeServer(difficulty, true)
                        end)
                    elseif selectedGrindItem:find("Time Trial") then
                        -- Time Trial â†’ only fire if TrialJoin UI is visible
                        if not TrialRF then
                            Rayfield:Notify({Title = "Error", Content = "TimeTrial remote missing", Duration = 6})
                            autoGrindEnabled = false
                            break
                        end
                        
                        local trialGui = StarterGui:FindFirstChild("TrialJoin")
                        local shouldFire = trialGui and trialGui.Enabled == true
                        
                        if shouldFire then
                            local difficulty = selectedGrindItem:match("Time Trial %- (%w+)") or "Easy"
                            success, result = pcall(function()
                                return TrialRF:InvokeServer(difficulty)
                            end)
                        else
                            print("[AutoGrind] Waiting for TrialJoin UI to appear...")
                        end
                    else
                        -- Demon Defense (Normal/Medium/Hard) â†’ always fires (no UI check requested)
                        if not DefenseRF then
                            Rayfield:Notify({Title = "Error", Content = "DemonDefense remote missing", Duration = 6})
                            autoGrindEnabled = false
                            break
                        end
                        
                        local difficulty = selectedGrindItem:match("Demon Defense %- (%w+)") or "Normal"
                        success, result = pcall(function()
                            return DefenseRF:InvokeServer(difficulty, true)
                        end)
                    end
                    
                    if success then
                        print("[AutoGrind] Started " .. selectedGrindItem .. " â†’ " .. tostring(result))
                    elseif success == false then
                        warn("[AutoGrind] Failed: " .. tostring(result))
                        Rayfield:Notify({
                            Title = "Start Failed",
                            Content = selectedGrindItem .. " - check cooldowns/console",
                            Duration = 5
                        })
                    end
                    
                    task.wait(FARM_DELAY + math.random(-15, 15))
                end
                
                Rayfield:Notify({
                    Title = "Auto Grind Stopped",
                    Content = "Loop paused.",
                    Duration = 4
                })
            end)
        else
            Rayfield:Notify({
                Title = "Auto Grind Stopped",
                Content = "Loop paused.",
                Duration = 4
            })
        end
    end,
})

-- Auto Farm Toggle - Targets & kills mobs close to the protected part in workspace.Mobs

local autoFarmEnabled = false
local currentTarget = nil
local PROTECTED_PART_CFRAME = CFrame.new(2132.10962, 10444.6211, -11089.9014, 0, 0, -1, -1, 0, 0, 0, 1, 0)
local CLOSE_DISTANCE = 50  -- studs; mobs closer than this to the part are targeted
local TELEPORT_OFFSET = CFrame.new(0, 3, -5)  -- adjust offset (behind & above mob)

-- Custom isMobAlive (for models with Humanoid)
local function isMobAlive(mobModel)
    local humanoid = mobModel:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

-- Custom teleport (player hrp to mob hrp with offset)
local function teleportToMob(playerHrp, mobData)
    if not playerHrp or not mobData or not mobData.root then return false end
    if not isMobAlive(mobData.obj) then return false end
    
    local targetCFrame = mobData.root.CFrame * TELEPORT_OFFSET
    playerHrp.CFrame = targetCFrame
    return true
end

MiscTab:CreateToggle({
    Name = "Auto Farm Selected",
    CurrentValue = false,
    Flag = "AutoMobFarm",

    Callback = function(enabled)
        autoFarmEnabled = enabled

        if enabled then
            task.spawn(function()
                while autoFarmEnabled do
                    task.wait(0.2)

                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if not hrp then continue end

                    -- Get alive mobs close to the protected part from workspace.Mobs
                    local aliveMobs = {}
                    
                    local mobsFolder = workspace:FindFirstChild("Mobs")
                    if not mobsFolder then
                        task.wait(1.5)
                        continue
                    end
                    
                    for _, obj in ipairs(mobsFolder:GetChildren()) do
                        if obj:IsA("Model") then
                            local humanoid = obj:FindFirstChildOfClass("Humanoid")
                            local rootPart = obj:FindFirstChild("HumanoidRootPart") or obj.PrimaryPart
                            
                            if humanoid and rootPart and humanoid.Health > 0 then
                                local distToPart = (PROTECTED_PART_CFRAME.Position - rootPart.Position).Magnitude
                                
                                if distToPart <= CLOSE_DISTANCE then
                                    local distToPlayer = (hrp.Position - rootPart.Position).Magnitude
                                    table.insert(aliveMobs, {
                                        obj = obj,
                                        root = rootPart,
                                        dist = distToPlayer,  -- sort by distance to player for efficiency
                                        mobType = obj.Name or "Mob"
                                    })
                                end
                            end
                        end
                    end
                    
                    -- Sort by distance to player (closest first)
                    table.sort(aliveMobs, function(a, b) return a.dist < b.dist end)

                    if #aliveMobs == 0 then
                        currentTarget = nil
                        task.wait(0.8)
                        continue
                    end

                    -- Validate/update current target
                    if currentTarget and currentTarget.obj then
                        local stillAlive = false
                        for _, mob in aliveMobs do
                            if mob.obj == currentTarget.obj then
                                currentTarget = mob
                                stillAlive = true
                                break
                            end
                        end
                        if not stillAlive then
                            currentTarget = nil
                        end
                    end

                    -- Pick closest if none or invalid
                    if not currentTarget then
                        currentTarget = aliveMobs[1]
                        print("Targeting â†’", currentTarget.mobType, math.floor(currentTarget.dist), "studs")
                    end

                    if not isMobAlive(currentTarget.obj) then
                        currentTarget = nil
                        continue
                    end

                    currentTarget.dist = (hrp.Position - currentTarget.root.Position).Magnitude

                    if currentTarget.dist > 7 then
                        teleportToMob(hrp, currentTarget)
                        task.wait(0.25)
                    else
                        task.wait(0.35)  -- already in range
                    end
                end
                currentTarget = nil
            end)
        else
            currentTarget = nil
        end
    end,
})

-- Auto Prestige Toggle (every 4 mins) - Add this after your MainTab is created

local autoPrestigeEnabled = false
local PRESTIGE_DELAY = 240  -- 4 minutes

MainTab:CreateToggle({
    Name = "Auto Prestige (4 min)",
    CurrentValue = false,
    Flag = "AutoPrestige",
    Callback = function(enabled)
        autoPrestigeEnabled = enabled
        
        if enabled then
            Rayfield:Notify({
                Title = "Auto Prestige Started",
                Content = "Prestiging every 4 minutes",
                Duration = 5
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local PrestigeRF
                
                -- Safely locate the RemoteFunction
                local pathSuccess = pcall(function()
                    PrestigeRF = ReplicatedStorage
                        :WaitForChild("Packages", 10)
                        :WaitForChild("_Index", 10)
                        :WaitForChild("sleitnick_knit@1.5.1", 10)
                        :WaitForChild("knit", 10)
                        :WaitForChild("Services", 10)
                        :WaitForChild("LevelService", 10)
                        :WaitForChild("RF", 10)
                        :WaitForChild("Prestige", 10)
                end)
                
                if not pathSuccess or not PrestigeRF then
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Prestige Remote not found. Stopping.",
                        Duration = 7
                    })
                    autoPrestigeEnabled = false
                    return
                end
                
                while autoPrestigeEnabled do
                    local success, result = pcall(function()
                        return PrestigeRF:InvokeServer()
                    end)
                    
                    if success then
                        print("[AutoPrestige] Success â†’ " .. tostring(result))
                    else
                        warn("[AutoPrestige] Failed: " .. tostring(result))
                        Rayfield:Notify({
                            Title = "Prestige Failed",
                            Content = "Check console / requirements.",
                            Duration = 6
                        })
                    end
                    
                    task.wait(PRESTIGE_DELAY + math.random(-20, 20))  -- ~4min Â±20s randomized
                end
            end)
        else
            Rayfield:Notify({
                Title = "Auto Prestige Stopped",
                Content = "Loop paused.",
                Duration = 4
            })
        end
    end,
})

RealMiscTab:CreateButton({
    Name = "ğŸ—‘ï¸ Destroy UI / Close Hub",
    Callback = function()
        -- Optional: ask for confirmation first
        Rayfield:Notify({
            Title = "Destroy UI?",
            Content = "This will completely remove the hub.\nYou will need to re-execute the script to bring it back.",
            Duration = 8,
            Actions = {
                Ignore = {
                    Name = "Cancel",
                    Callback = function()
                        -- do nothing
                    end
                },
                Confirm = {
                    Name = "Yes, Destroy",
                    Callback = function()
                        -- Actually destroy the UI
                        pcall(function()
                            if Window then
                                Window:Destroy()
                            end
                        end)

                        -- Try to clean up any leftover ScreenGui
                        pcall(function()
                            for _, gui in ipairs(player.PlayerGui:GetChildren()) do
                                if gui:IsA("ScreenGui") and (gui.Name:lower():find("rayfield") or gui.Name == "ThaBooHub") then
                                    gui:Destroy()
                                end
                            end
                        end)

                        -- Final feedback
                        game.StarterGui:SetCore("SendNotification", {
                            Title = "UI Destroyed",
                            Text = "Hub closed. Re-execute script to reopen.",
                            Duration = 6
                        })

                        print("[Tha Boo Hub] UI has been destroyed")
                    end
                }
            }
        })
    end,
})
