local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet("https://sirius.menu/rayfield", true))()
end)

if not success or not Rayfield then
    warn("Rayfield failed to load! Error: " .. tostring(Rayfield))
    local sg = Instance.new("ScreenGui")
    local tx = Instance.new("TextLabel", sg)
    tx.Size = UDim2.new(1,0,1,0)
    tx.BackgroundColor3 = Color3.new(0,0,0)
    tx.TextColor3 = Color3.new(1,0,0)
    tx.Text = "Failed to load UI library.\nCheck executor / internet / script source."
    tx.TextScaled = true
    sg.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    return
end

local Window = Rayfield:CreateWindow({ Name = "Your Hub", ... })
task.wait(0.1)
local MainTab = Window:CreateTab("Player", nil) 

-- Variables
local autoClick = false
local autoStat = false
local selectedStat = "Energy"  -- Default

-- Auto Clicker Toggle
local ClickToggle = MainTab:CreateToggle({
    Name = "Auto Clicker",
    CurrentValue = false,
    Flag = "AutoClickToggle",
    
    Callback = function(Value)
        autoClick = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Clicker",
                Content = "Clicking every ~0.03s...",
                Duration = 3
            })
            
            task.spawn(function()
                while autoClick do
                    pcall(function()
                        local clickRemote = game:GetService("ReplicatedStorage")
                            :WaitForChild("Packages")
                            :WaitForChild("_Index")
                            :WaitForChild("sleitnick_knit@1.5.1")
                            :WaitForChild("knit")
                            :WaitForChild("Services")
                            :WaitForChild("ClickService")
                            :WaitForChild("RF")
                            :WaitForChild("Click")
                        
                        clickRemote:InvokeServer()
                    end)
                    
                    task.wait(0.1)
                end
            end)
        end
    end,
})


local AutoRankUpToggle = MainTab:CreateToggle({
    Name = "Auto Rank Up",
    CurrentValue = false,
    Flag = "AutoRankUp",
    
    Callback = function(Value)
        getgenv().AutoRankUp = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Rank Up",
                Content = "Ranking up every 60s...",
                Duration = 4
            })
            
            task.spawn(function()
                while getgenv().AutoRankUp do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Packages")
                            :WaitForChild("_Index")
                            :WaitForChild("sleitnick_knit@1.5.1")
                            :WaitForChild("knit")
                            :WaitForChild("Services")
                            :WaitForChild("RankupService")
                            :WaitForChild("RF")
                            :WaitForChild("RankUp")
                            :InvokeServer()
                    end)
                    
                    if not success then
                        warn("Auto Rank Up error: " .. tostring(err))
                        Rayfield:Notify({
                            Title = "Auto Rank Up Error",
                            Content = "Failed to rank up ‚Äì check console. Stopping...",
                            Duration = 6
                        })
                        getgenv().AutoRankUp = false
                        break
                    end
                    
                    task.wait(60)
                end
            end)
        else
            Rayfield:Notify({
                Title = "Auto Rank Up",
                Content = "Stopped.",
                Duration = 3
            })
        end
    end,
})


task.wait(1)
local MiscTab = Window:CreateTab("Game", nil)   

local rerollTypes = {
    "Saiyan",
    "Dragon",
    "Chakra",
    "Jinchuriki",
    "Haki",
    "Devil",
    "Reiatsu",
    "Voltstanding",
    "Breathing",
    "Demon Art",
    "Curse",
    "Cursed Technique"
}

-- Dropdown (single selection for simplicity - change to MultipleOptions = true if you want multi)
local selectedReroll = "Saiyan"  -- default

local RerollDropdown = MiscTab:CreateDropdown({
    Name = "Select Reroll",
    Options = rerollTypes,
    CurrentOption = {"Saiyan"},
    MultipleOptions = false,
    Flag = "RerollType",
    Callback = function(option)
        selectedReroll = option[1]
        Rayfield:Notify({
            Title = "Reroll Updated",
            Content = "Now set to: " .. selectedReroll,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Toggle for auto-reroll loop
local autoRerollEnabled = false

local AutoRerollToggle = MiscTab:CreateToggle({
    Name = "Auto Reroll",
    CurrentValue = false,
    Flag = "AutoReroll",
    Callback = function(Value)
        autoRerollEnabled = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Reroll Started",
                Content = "Rerolling " .. selectedReroll .. " ",
                Duration = 1
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RerollRF
                
                -- Safe path to the RemoteFunction
                local success, err = pcall(function()
                    local knit = ReplicatedStorage:WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("RerollableService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("Reroll", 8)
                    RerollRF = knit
                end)
                
                if not success or not RerollRF then
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Could not find Reroll RemoteFunction.\nCheck game path or anti-exploit.",
                        Duration = 1
                    })
                    autoRerollEnabled = false
                    AutoRerollToggle:Set(false)
                    return
                end
                
                while autoRerollEnabled do
                    local args = { selectedReroll }
                    
                    local success, result = pcall(function()
                        return RerollRF:InvokeServer(unpack(args))
                    end)
                    
                    if success then
                        print("Reroll attempted for: " .. selectedReroll .. " ‚Üí Result: " .. tostring(result))
                    else
                        warn("Reroll failed: " .. tostring(result))
                    end
                    
                    -- Adjust delay based on your needs (anti-kick / rate-limit friendly)
                    task.wait(3.5 + math.random(0.5, 2))  -- ~3.5‚Äì5.5 seconds
                end
            end)
        else
            Rayfield:Notify({
                Title = "Auto Reroll Stopped",
                Content = "Loop paused.",
                Duration = 1
            })
        end
    end,
})


-- =====================================
-- Machines Dropdown with AUTO-TELEPORT on Selection
-- =====================================

local machinesFolder = workspace:WaitForChild("Machines")
local player = game.Players.LocalPlayer

local function getMachineNames()
    local names = {}
    local seen = {}

    for _, child in ipairs(machinesFolder:GetChildren()) do
        local name = child.Name
        if name and not seen[name] then
            seen[name] = true
            table.insert(names, name)
        end
    end

    table.sort(names)
    
    if #names == 0 then
        table.insert(names, "No machines found")
    end
    
    return names
end

-- Dropdown - Teleports instantly on selection
local MachinesDropdown = MiscTab:CreateDropdown({
    Name = "Select Machine (Auto-TP)",
    Options = getMachineNames(),
    CurrentOption = {"None"},
    MultipleOptions = false,
    Flag = "MachineTPDropdown",
    
    Callback = function(Option)
        local selectedMachine = Option and Option[1]  -- Extract string
        
        if not selectedMachine or selectedMachine == "No machines found" or selectedMachine == "None" then
            return  -- Do nothing if invalid
        end
        
        -- Notify selection
        Rayfield:Notify({
            Title = "Teleporting...",
            Content = "Moving to: " .. selectedMachine,
            Duration = 1
        })
        print("Auto-TP to machine:", selectedMachine)
        
        -- Find the machine
        local machine = machinesFolder:FindFirstChild(selectedMachine)
        if not machine then
            Rayfield:Notify({
                Title = "Error",
                Content = selectedMachine .. " not found",
                Duration = 1
            })
            return
        end
        
        -- Get HRP from workspace.Players
        local playerFolder = workspace:FindFirstChild("Players")
        if not playerFolder then
            Rayfield:Notify({Title = "Error", Content = "Players folder not found", Duration = 4})
            return
        end
        
        local playerChar = playerFolder:FindFirstChild(player.Name)
        if not playerChar then
            Rayfield:Notify({Title = "Error", Content = "Your character not found", Duration = 4})
            return
        end
        
        local hrp = playerChar:FindFirstChild("HumanoidRootPart")
        if not hrp then
            Rayfield:Notify({Title = "Error", Content = "No HumanoidRootPart found", Duration = 4})
            return
        end
        
        -- Get target CFrame (handles Parts/Models)
        local targetCFrame
        if machine.PrimaryPart then
            targetCFrame = machine.PrimaryPart.CFrame
        elseif machine:IsA("BasePart") then
            targetCFrame = machine.CFrame
        else
            local firstPart = machine:FindFirstChildWhichIsA("BasePart", true)
            targetCFrame = firstPart and firstPart.CFrame or CFrame.new(machine.Position or Vector3.new())
        end
        
        -- Teleport 5 studs above
        local success, err = pcall(function()
            hrp.CFrame = targetCFrame + Vector3.new(0, 5, 0)
        end)
        
        if success then
            print("Auto-teleported to:", selectedMachine)
        else
            warn("TP failed:", tostring(err))
            Rayfield:Notify({
                Title = "Teleport Failed",
                Content = "Check console for error",
                Duration = 1
            })
        end
    end,
})

-- Optional: Refresh button (still useful)
MiscTab:CreateButton({
    Name = "Refresh Machines List",
    Callback = function()
        local newOptions = getMachineNames()
        MachinesDropdown:Refresh(newOptions, true)
        MachinesDropdown:Set({"None"})
        Rayfield:Notify({
            Title = "Refreshed",
            Content = #newOptions .. " machines found",
            Duration = 1
        })
    end,
})


-- =====================================
-- AUTO FARM - Detects current map from workspace.Maps + Mobs from MobSpawns
-- Dropdown shows only mobs on your current island
-- =====================================
task.wait(0.5)
local FarmTab = Window:CreateTab("Auto Farm", 4483362458)

-- LocalScript (Rayfield UI - Farming Tab)

local player = game.Players.LocalPlayer
local workspace = game.Workspace

local mapsFolder    = workspace:WaitForChild("Maps")
local mobSpawnsFolder = workspace:WaitForChild("MobSpawns")

local selectedMobTypes = {}     -- table of selected mob names/types
local currentTarget    = nil    -- {obj, dist, mobType, root}

local currentMapFolder = nil
local currentMobFolder = nil

-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- Map Detection & Mob Type Collection
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

local function detectCurrentMap()
    local character = player.Character
    if not character then return nil end

    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local playerPos = root.Position
    local closestMapName = nil
    local minAvgDist = math.huge

    for _, mapFolder in mapsFolder:GetChildren() do
        if mapFolder:IsA("Folder") or mapFolder:IsA("Model") then
            local mapName = mapFolder.Name
            local mobFolder = mobSpawnsFolder:FindFirstChild(mapName)

            if mobFolder and #mobFolder:GetChildren() > 0 then
                local totalDist = 0
                local count = 0

                for _, mob in mobFolder:GetChildren() do
                    local mobRoot = (mob:IsA("Model") and mob:FindFirstChild("HumanoidRootPart")) or (mob:IsA("BasePart") and mob)
                    if mobRoot then
                        totalDist += (playerPos - mobRoot.Position).Magnitude
                        count += 1
                    end
                end

                if count > 0 then
                    local avgDist = totalDist / count
                    if avgDist < minAvgDist then
                        minAvgDist = avgDist
                        closestMapName = mapName
                        currentMapFolder = mapFolder
                        currentMobFolder = mobFolder
                    end
                end
            end
        end
    end

    return closestMapName
end

local function getMobTypes()
    if not currentMobFolder then
        return {"Scan map first"}
    end

    local types = {}
    local seen = {}

    for _, child in currentMobFolder:GetChildren() do
        local mobType

        -- Prefer attribute if present (more reliable in many games)
        if child:GetAttribute("Name") then
            mobType = tostring(child:GetAttribute("Name"))
        else
            -- Fallback: clean object name
            mobType = child.Name
                :gsub("_%d+$", "")
                :gsub("Clone", "")
                :match("^%s*(.-)%s*$")
        end

        if mobType and #mobType > 0 and not seen[mobType] then
            seen[mobType] = true
            table.insert(types, mobType)
        end
    end

    table.sort(types)
    return #types > 0 and types or {"No mobs found on this map"}
end

-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- Alive Check (stronger version from enemy code)
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

local function isMobAlive(target)
    local part = target:IsA("Model") and target:FindFirstChildWhichIsA("BasePart", true) or target
    if not part or not part.Parent then return false end

    -- UUID check (common despawn indicator)
    if part:GetAttribute("UUID") == nil then return false end

    -- Explicit Dead flag
    if part:GetAttribute("Dead") == true then return false end

    -- Health attribute
    local health = part:GetAttribute("Health")
    if health ~= nil and health <= 0 then return false end

    -- Optional Humanoid fallback
    local humanoid = target:FindFirstChildOfClass("Humanoid") or part.Parent:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return false end

    return true
end

-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- Get alive mobs from selected types, sorted by distance
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

local function getAliveMobs()
    if #selectedMobTypes == 0 or (#selectedMobTypes == 1 and selectedMobTypes[1] == "None") then
        return {}
    end

    if not currentMobFolder then return {} end

    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return {} end

    local allowed = {}
    for _, t in selectedMobTypes do
        if t ~= "None" and t ~= "Scan map first" and t ~= "No mobs found on this map" then
            allowed[t] = true
        end
    end

    local aliveList = {}
    for _, obj in currentMobFolder:GetChildren() do
        local mobType = obj:GetAttribute("Name") or
            obj.Name:gsub("_%d+$", ""):gsub("Clone", ""):match("^%s*(.-)%s*$")

        if mobType and allowed[mobType] and isMobAlive(obj) then
            local rootPart = (obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart")) or
                             (obj:IsA("BasePart") and obj)

            if rootPart then
                local dist = (hrp.Position - rootPart.Position).Magnitude
                table.insert(aliveList, {
                    obj     = obj,
                    root    = rootPart,
                    dist    = dist,
                    mobType = mobType
                })
            end
        end
    end

    table.sort(aliveList, function(a,b) return a.dist < b.dist end)
    return aliveList
end

-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- Teleport helper
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

local function teleportToMob(hrp, mobData)
    if not hrp or not mobData or not mobData.root then return false end
    if not isMobAlive(mobData.obj) then return false end

    local offset = CFrame.new(0, 3, -5)   -- behind + above; adjust to taste
    hrp.CFrame = mobData.root.CFrame * offset
    return true
end

-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- UI Elements (on your FarmTab or main Tab)
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

local MobDropdown = FarmTab:CreateDropdown({
    Name = "Select Mobs to Farm",
    Options = {"Scan map first"},
    CurrentOption = {"Scan map first"},
    MultipleOptions = true,
    Flag = "MobFarmSelector",

    Callback = function(selected)
        selectedMobTypes = selected
        if #selected == 0 or (#selected == 1 and (selected[1] == "None" or selected[1] == "Scan map first")) then
            currentTarget = nil
        end
    end,
})

FarmTab:CreateButton({
    Name = "üîç Scan Current Map & Refresh Mobs",
    Callback = function()
        currentMapFolder = nil
        currentMobFolder = nil

        local mapName = detectCurrentMap()

        if mapName then
            local mobCount = currentMobFolder and #currentMobFolder:GetChildren() or 0
            local types = getMobTypes()
            local typesCount = #types > 0 and (#types == 1 and types[1] == "No mobs found on this map" and 0 or #types) or 0

            Rayfield:Notify({
                Title = "Map Detected",
                Content = mapName .. " (" .. mobCount .. " mobs, " .. typesCount .. " types)",
                Duration = 5
            })

            MobDropdown:Refresh(types, true)
        else
            Rayfield:Notify({
                Title = "No Map / Mobs Detected",
                Content = "Move closer to a mob spawn area",
                Duration = 6
            })
            MobDropdown:Refresh({"Scan map first"}, true)
        end
    end,
})

FarmTab:CreateToggle({
    Name = "Auto Teleport to Closest Selected Mob",
    CurrentValue = false,
    Flag = "AutoMobFarm",

    Callback = function(enabled)
        getgenv().AutoMobFarm = enabled

        if enabled then
            task.spawn(function()
                while getgenv().AutoMobFarm do
                    task.wait(0.2)

                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if not hrp then continue end

                    local aliveMobs = getAliveMobs()
                    if #aliveMobs == 0 then
                        currentTarget = nil
                        task.wait(0.8)
                        continue
                    end

                    -- Validate/update current target
                    if currentTarget and currentTarget.obj then
                        local stillAlive = false
                        for _, mob in aliveMobs do
                            if mob.obj == currentTarget.obj then
                                currentTarget = mob
                                stillAlive = true
                                break
                            end
                        end
                        if not stillAlive then
                            currentTarget = nil
                        end
                    end

                    -- Pick closest if none or invalid
                    if not currentTarget then
                        currentTarget = aliveMobs[1]
                        print("Targeting ‚Üí", currentTarget.mobType, math.floor(currentTarget.dist), "studs")
                    end

                    if not isMobAlive(currentTarget.obj) then
                        currentTarget = nil
                        continue
                    end

                    currentTarget.dist = (hrp.Position - currentTarget.root.Position).Magnitude

                    if currentTarget.dist > 7 then
                        teleportToMob(hrp, currentTarget)
                        task.wait(0.25)
                    else
                        task.wait(0.35)  -- already in range
                    end
                end
                currentTarget = nil
            end)
        else
            currentTarget = nil
        end
    end,
})

-- Auto Stat Upgrade (every 60 seconds) - Add this after your MainTab is created

local stats = {
    "Energy",
    "Gems",
    "Luck",
    "Damage"
}

local selectedStat = "Energy"   -- default
local autoUpgradeEnabled = false
local UPGRADE_DELAY = 60        -- fixed 1 minute

-- Dropdown for stat selection
local StatDropdown = MainTab:CreateDropdown({
    Name = "Select Stat to Upgrade",
    Options = stats,
    CurrentOption = {"Energy"},
    MultipleOptions = false,
    Flag = "AutoStatType",
    Callback = function(option)
        selectedStat = option[1]
        Rayfield:Notify({
            Title = "Stat Updated",
            Content = "Now auto-upgrading: " .. selectedStat,
            Duration = 4
        })
    end,
})

-- Toggle for auto-upgrade loop (every 60 seconds)
MainTab:CreateToggle({
    Name = "Auto Upgrade Stat",
    CurrentValue = false,
    Flag = "AutoStatUpgrade",
    Callback = function(enabled)
        autoUpgradeEnabled = enabled
        
        if enabled then
            Rayfield:Notify({
                Title = "Auto Upgrade Started",
                Content = "Upgrading " .. selectedStat .. " every 60 seconds",
                Duration = 5
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local PutStatRF
                
                -- Safely get the RemoteFunction
                local pathSuccess, pathErr = pcall(function()
                    PutStatRF = ReplicatedStorage
                        :WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("LevelService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("PutStat", 8)
                end)
                
                if not pathSuccess or not PutStatRF then
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Could not find PutStat Remote.\nPath might have changed.",
                        Duration = 7
                    })
                    autoUpgradeEnabled = false
                    return
                end
                
                while autoUpgradeEnabled do
                    local success, result = pcall(function()
                        return PutStatRF:InvokeServer(selectedStat, 1)
                    end)
                    
                    if success then
                        print("[AutoStat] Upgraded " .. selectedStat .. " +1 ‚Üí " .. tostring(result))
                    else
                        warn("[AutoStat] Failed: " .. tostring(result))
                        Rayfield:Notify({
                            Title = "Upgrade Failed",
                            Content = "Error during stat upgrade. Check console.",
                            Duration = 6
                        })
                    end
                    
                    task.wait(UPGRADE_DELAY)  -- exactly 60 seconds
                end
                
                Rayfield:Notify({
                    Title = "Auto Upgrade Stopped",
                    Content = "No more upgrades for " .. selectedStat,
                    Duration = 3
                })
            end)
        else
            Rayfield:Notify({
                Title = "Auto Upgrade Stopped",
                Content = "Loop paused.",
                Duration = 3
            })
        end
    end,
})

task.wait(0.6)
local RealMiscTab = Window:CreateTab("Misc", nil)

-- Misc Tab Features: Anti-AFK, Speed, Inf Jump, Performance
-- Add this AFTER: local MiscTab = Window:CreateTab("Misc", nil)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Anti-AFK Variables
local antiAFKEnabled = false
local antiAFKConnection = nil

-- Speed Variables
local defaultWalkSpeed = 16
local speedConnection = nil

-- Inf Jump Variables
local infJumpEnabled = false
local infJumpConnection = nil

-- Performance Variables
local performanceEnabled = false
local originalSettings = {}

-- 1. ANTI-AFK TOGGLE (actually works - uses VirtualUser)
RealMiscTab:CreateToggle({
    Name = "Anti AFK (Working)",
    CurrentValue = false,
    Flag = "AntiAFK",
    Callback = function(enabled)
        antiAFKEnabled = enabled
        
        if enabled then
            Rayfield:Notify({
                Title = "Anti AFK",
                Content = "Activated - simulates inputs every ~60s",
                Duration = 4
            })
            
            VirtualUser:CaptureController()
            VirtualUser:SetKeyDown("0x00")  -- Dummy key
            
            antiAFKConnection = task.spawn(function()
                while antiAFKEnabled do
                    task.wait(math.random(55, 65))  -- 55-65s random
                    
                    -- Simulate right-click + move
                    VirtualUser:ClickButton2(Vector2.new(0, 0))
                    task.wait(0.1)
                    VirtualUser:ClickButton2(Vector2.new(0, 0))
                end
                VirtualUser:ReleaseController()
            end)
        else
            Rayfield:Notify({
                Title = "Anti AFK",
                Content = "Deactivated",
                Duration = 3
            })
            if antiAFKConnection then
                task.cancel(antiAFKConnection)
                antiAFKConnection = nil
            end
            VirtualUser:ReleaseController()
        end
    end,
})

-- 2. SPEED SLIDER (16-500)
RealMiscTab:CreateSlider({
    Name = "Walk Speed",
    Range = {16, 500},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Flag = "WalkSpeed",
    Callback = function(value)
        getgenv().WalkSpeedValue = value
        
        if speedConnection then
            speedConnection:Disconnect()
        end
        
        speedConnection = RunService.Heartbeat:Connect(function()
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid.WalkSpeed = value
            end
        end)
    end,
})

-- 3. INFINITE JUMPS TOGGLE
RealMiscTab:CreateToggle({
    Name = "Infinite Jumps",
    CurrentValue = false,
    Flag = "InfJump",
    Callback = function(enabled)
        infJumpEnabled = enabled
        
        if enabled then
            Rayfield:Notify({
                Title = "Infinite Jumps",
                Content = "Hold space to fly/jump forever",
                Duration = 4
            })
            
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid:ChangeState("Jumping")
                end
            end)
        else
            Rayfield:Notify({
                Title = "Infinite Jumps",
                Content = "Disabled",
                Duration = 3
            })
            if infJumpConnection then
                infJumpConnection:Disconnect()
                infJumpConnection = nil
            end
        end
    end,
})

-- 4. PERFORMANCE BUTTON (FPS Boost - toggles low graphics)
RealMiscTab:CreateButton({
    Name = "üñ•Ô∏è FPS Boost / Performance Mode",
    Callback = function()
        performanceEnabled = not performanceEnabled
        
        if performanceEnabled then
            -- Save originals
            originalSettings = {
                GlobalShadows = Lighting.GlobalShadows,
                Brightness = Lighting.Brightness,
                ClockTime = Lighting.ClockTime,
                FogEnd = Lighting.FogEnd,
                FogStart = Lighting.FogStart,
            }
            
            -- Apply low graphics
            Lighting.GlobalShadows = false
            Lighting.Brightness = 2
            Lighting.ClockTime = 14
            Lighting.FogEnd = 100000
            Lighting.FogStart = 0
            Lighting.GeographicLatitude = 0
            Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
            
            -- Workspace optimizations
            for _, v in workspace:GetDescendants() do
                if v:IsA("Explosion") then v:Destroy() end
                if v:IsA("Fire") or v:IsA("Sparkles") then v:Destroy() end
                if v:IsA("Smoke") or v:IsA("Light") then v:Destroy() end
            end
            
            -- Reduce particle emitters
            for _, obj in workspace:GetDescendants() do
                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                    obj.Lifetime = NumberRange.new(0)
                    obj.Rate = 0
                end
            end
            
            Rayfield:Notify({
                Title = "Performance Mode ON",
                Content = "FPS boosted! Shadows off, effects cleared.",
                Duration = 5
            })
        else
            -- Restore originals
            pcall(function()
                Lighting.GlobalShadows = originalSettings.GlobalShadows
                Lighting.Brightness = originalSettings.Brightness
                Lighting.ClockTime = originalSettings.ClockTime
                Lighting.FogEnd = originalSettings.FogEnd
                Lighting.FogStart = originalSettings.FogStart
            end)
            
            Rayfield:Notify({
                Title = "Performance Mode OFF",
                Content = "Graphics restored.",
                Duration = 4
            })
        end
    end,
})

-- Game Modes Dropdown with AUTO REFRESH - Add this after your tab is created

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Helper function: scan Gamemodes folder for all mode names
local function getGameModes()
    local options = {"None"}
    
    local gamemodesFolder = ReplicatedStorage:FindFirstChild("Gamemodes")
    if not gamemodesFolder then
        warn("[GameModes] Folder not found in ReplicatedStorage")
        return options
    end
    
    local seen = {}
    
    -- Scan direct children
    for _, child in ipairs(gamemodesFolder:GetChildren()) do
        local name = child.Name
        if name and name ~= "" and not seen[name] then
            seen[name] = true
            table.insert(options, name)
        end
    end
    
    -- Also scan descendants (subfolders, values, etc.)
    for _, child in ipairs(gamemodesFolder:GetDescendants()) do
        local name
        
        -- Prefer attribute if it exists (some games use Attributes)
        if child:GetAttribute("Name") then
            name = tostring(child:GetAttribute("Name"))
        else
            name = child.Name
        end
        
        if name and name ~= "" and not seen[name] then
            seen[name] = true
            table.insert(options, name)
        end
    end
    
    table.sort(options)
    return options
end

-- Dropdown
local selectedGameMode = "None"

local GameModeDropdown = RealMiscTab:CreateDropdown({   -- ‚Üê change to your tab: MiscTab, FarmTab, etc.
    Name = "Select Game Mode",
    Options = getGameModes(),
    CurrentOption = {"None"},
    MultipleOptions = false,
    Flag = "GameModeSelector",
    Callback = function(option)
        selectedGameMode = option[1]
        
        if selectedGameMode == "None" then
            Rayfield:Notify({
                Title = "Game Mode",
                Content = "Selection cleared",
                Duration = 3
            })
        else
            Rayfield:Notify({
                Title = "Game Mode Selected",
                Content = "Now set to: " .. selectedGameMode,
                Duration = 4
            })
            print("[GameMode] Selected:", selectedGameMode)
            
            -- Optional: do something with the selection
            -- e.g. fire remote, set variable, start mode-specific script
        end
    end,
})

-- Manual refresh button (still useful)
RealMiscTab:CreateButton({
    Name = "üîÑ Refresh Game Modes",
    Callback = function()
        local newOptions = getGameModes()
        GameModeDropdown:Refresh(newOptions, false)  -- false = keep current selection if possible
        
        Rayfield:Notify({
            Title = "Game Modes Updated",
            Content = "Found " .. (#newOptions - 1) .. " modes",
            Duration = 4
        })
    end,
})

-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- AUTO REFRESH when folder contents change
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

local function autoRefreshGameModes()
    if not GameModeDropdown then return end
    
    local newOptions = getGameModes()
    -- false = try to keep current selection if it still exists
    GameModeDropdown:Refresh(newOptions, false)
    
    -- Optional: only notify if count changed significantly
    print("[AutoRefresh] Game modes updated - now " .. (#newOptions - 1) .. " options")
end

-- Connect to changes in the folder
local gamemodesFolder = ReplicatedStorage:WaitForChild("Gamemodes", 10)

if gamemodesFolder then
    -- Child added / removed / renamed
    gamemodesFolder.ChildAdded:Connect(autoRefreshGameModes)
    gamemodesFolder.ChildRemoved:Connect(autoRefreshGameModes)
    
    -- Also listen for deeper changes (attributes, name changes in descendants)
    gamemodesFolder.DescendantAdded:Connect(autoRefreshGameModes)
    gamemodesFolder.DescendantRemoving:Connect(autoRefreshGameModes)
    
    -- Optional: watch for attribute changes (if modes use attributes)
    gamemodesFolder.DescendantAdded:Connect(function(desc)
        desc:GetPropertyChangedSignal("Name"):Connect(autoRefreshGameModes)
        desc:GetAttributeChangedSignal("Name"):Connect(autoRefreshGameModes)
    end)
    
    print("[GameModes] Auto-refresh enabled on folder changes")
else
    warn("[GameModes] Folder not found - auto-refresh disabled")
end

-- Initial scan
task.delay(1, autoRefreshGameModes)
