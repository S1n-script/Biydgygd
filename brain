local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet("https://sirius.menu/rayfield", true))()
end)

if not success or not Rayfield then
    warn("Rayfield failed to load! Error: " .. tostring(Rayfield))
    local sg = Instance.new("ScreenGui")
    local tx = Instance.new("TextLabel", sg)
    tx.Size = UDim2.new(1,0,1,0)
    tx.BackgroundColor3 = Color3.new(0,0,0)
    tx.TextColor3 = Color3.new(1,0,0)
    tx.Text = "Failed to load UI library.\nCheck executor / internet / script source."
    tx.TextScaled = true
    sg.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    return
end

local Window = Rayfield:CreateWindow({ Name = "Your Hub", ... })
task.wait(0.1)
local MainTab = Window:CreateTab("Main", nil) 

-- Variables
local autoClick = false
local autoStat = false
local selectedStat = "Energy"  -- Default

-- Auto Clicker Toggle
local ClickToggle = MainTab:CreateToggle({
    Name = "Auto Clicker",
    CurrentValue = false,
    Flag = "AutoClickToggle",
    
    Callback = function(Value)
        autoClick = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Clicker",
                Content = "Clicking every ~0.03s...",
                Duration = 3
            })
            
            task.spawn(function()
                while autoClick do
                    pcall(function()
                        local clickRemote = game:GetService("ReplicatedStorage")
                            :WaitForChild("Packages")
                            :WaitForChild("_Index")
                            :WaitForChild("sleitnick_knit@1.5.1")
                            :WaitForChild("knit")
                            :WaitForChild("Services")
                            :WaitForChild("ClickService")
                            :WaitForChild("RF")
                            :WaitForChild("Click")
                        
                        clickRemote:InvokeServer()
                    end)
                    
                    task.wait(0.1)
                end
            end)
        end
    end,
})


local AutoRankUpToggle = MainTab:CreateToggle({
    Name = "Auto Rank Up",
    CurrentValue = false,
    Flag = "AutoRankUp",
    
    Callback = function(Value)
        getgenv().AutoRankUp = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Rank Up",
                Content = "Ranking up every 60s...",
                Duration = 4
            })
            
            task.spawn(function()
                while getgenv().AutoRankUp do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Packages")
                            :WaitForChild("_Index")
                            :WaitForChild("sleitnick_knit@1.5.1")
                            :WaitForChild("knit")
                            :WaitForChild("Services")
                            :WaitForChild("RankupService")
                            :WaitForChild("RF")
                            :WaitForChild("RankUp")
                            :InvokeServer()
                    end)
                    
                    if not success then
                        warn("Auto Rank Up error: " .. tostring(err))
                        Rayfield:Notify({
                            Title = "Auto Rank Up Error",
                            Content = "Failed to rank up â€“ check console. Stopping...",
                            Duration = 6
                        })
                        getgenv().AutoRankUp = false
                        break
                    end
                    
                    task.wait(60)
                end
            end)
        else
            Rayfield:Notify({
                Title = "Auto Rank Up",
                Content = "Stopped.",
                Duration = 3
            })
        end
    end,
})


task.wait(1)
local MiscTab = Window:CreateTab("Misc", nil)   

local rerollTypes = {
    "Saiyan",
    "Dragon",
    "Chakra",
    "Jinchuriki",
    "Haki",
    "Devil",
    "Reiatsu",
    "Voltstanding",
    "Breathing",
    "Demon Art",
    "Curse",
    "Cursed Technique"
}

-- Dropdown (single selection for simplicity - change to MultipleOptions = true if you want multi)
local selectedReroll = "Saiyan"  -- default

local RerollDropdown = MiscTab:CreateDropdown({
    Name = "Select Reroll",
    Options = rerollTypes,
    CurrentOption = {"Saiyan"},
    MultipleOptions = false,
    Flag = "RerollType",
    Callback = function(option)
        selectedReroll = option[1]
        Rayfield:Notify({
            Title = "Reroll Updated",
            Content = "Now set to: " .. selectedReroll,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Toggle for auto-reroll loop
local autoRerollEnabled = false

local AutoRerollToggle = MiscTab:CreateToggle({
    Name = "Auto Reroll",
    CurrentValue = false,
    Flag = "AutoReroll",
    Callback = function(Value)
        autoRerollEnabled = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Reroll Started",
                Content = "Rerolling " .. selectedReroll .. " ",
                Duration = 1
            })
            
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RerollRF
                
                -- Safe path to the RemoteFunction
                local success, err = pcall(function()
                    local knit = ReplicatedStorage:WaitForChild("Packages", 8)
                        :WaitForChild("_Index", 8)
                        :WaitForChild("sleitnick_knit@1.5.1", 8)
                        :WaitForChild("knit", 8)
                        :WaitForChild("Services", 8)
                        :WaitForChild("RerollableService", 8)
                        :WaitForChild("RF", 8)
                        :WaitForChild("Reroll", 8)
                    RerollRF = knit
                end)
                
                if not success or not RerollRF then
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Could not find Reroll RemoteFunction.\nCheck game path or anti-exploit.",
                        Duration = 1
                    })
                    autoRerollEnabled = false
                    AutoRerollToggle:Set(false)
                    return
                end
                
                while autoRerollEnabled do
                    local args = { selectedReroll }
                    
                    local success, result = pcall(function()
                        return RerollRF:InvokeServer(unpack(args))
                    end)
                    
                    if success then
                        print("Reroll attempted for: " .. selectedReroll .. " â†’ Result: " .. tostring(result))
                    else
                        warn("Reroll failed: " .. tostring(result))
                    end
                    
                    -- Adjust delay based on your needs (anti-kick / rate-limit friendly)
                    task.wait(3.5 + math.random(0.5, 2))  -- ~3.5â€“5.5 seconds
                end
            end)
        else
            Rayfield:Notify({
                Title = "Auto Reroll Stopped",
                Content = "Loop paused.",
                Duration = 1
            })
        end
    end,
})


-- =====================================
-- Machines Dropdown with AUTO-TELEPORT on Selection
-- =====================================

local machinesFolder = workspace:WaitForChild("Machines")
local player = game.Players.LocalPlayer

local function getMachineNames()
    local names = {}
    local seen = {}

    for _, child in ipairs(machinesFolder:GetChildren()) do
        local name = child.Name
        if name and not seen[name] then
            seen[name] = true
            table.insert(names, name)
        end
    end

    table.sort(names)
    
    if #names == 0 then
        table.insert(names, "No machines found")
    end
    
    return names
end

-- Dropdown - Teleports instantly on selection
local MachinesDropdown = MiscTab:CreateDropdown({
    Name = "Select Machine (Auto-TP)",
    Options = getMachineNames(),
    CurrentOption = {"None"},
    MultipleOptions = false,
    Flag = "MachineTPDropdown",
    
    Callback = function(Option)
        local selectedMachine = Option and Option[1]  -- Extract string
        
        if not selectedMachine or selectedMachine == "No machines found" or selectedMachine == "None" then
            return  -- Do nothing if invalid
        end
        
        -- Notify selection
        Rayfield:Notify({
            Title = "Teleporting...",
            Content = "Moving to: " .. selectedMachine,
            Duration = 1
        })
        print("Auto-TP to machine:", selectedMachine)
        
        -- Find the machine
        local machine = machinesFolder:FindFirstChild(selectedMachine)
        if not machine then
            Rayfield:Notify({
                Title = "Error",
                Content = selectedMachine .. " not found",
                Duration = 1
            })
            return
        end
        
        -- Get HRP from workspace.Players
        local playerFolder = workspace:FindFirstChild("Players")
        if not playerFolder then
            Rayfield:Notify({Title = "Error", Content = "Players folder not found", Duration = 4})
            return
        end
        
        local playerChar = playerFolder:FindFirstChild(player.Name)
        if not playerChar then
            Rayfield:Notify({Title = "Error", Content = "Your character not found", Duration = 4})
            return
        end
        
        local hrp = playerChar:FindFirstChild("HumanoidRootPart")
        if not hrp then
            Rayfield:Notify({Title = "Error", Content = "No HumanoidRootPart found", Duration = 4})
            return
        end
        
        -- Get target CFrame (handles Parts/Models)
        local targetCFrame
        if machine.PrimaryPart then
            targetCFrame = machine.PrimaryPart.CFrame
        elseif machine:IsA("BasePart") then
            targetCFrame = machine.CFrame
        else
            local firstPart = machine:FindFirstChildWhichIsA("BasePart", true)
            targetCFrame = firstPart and firstPart.CFrame or CFrame.new(machine.Position or Vector3.new())
        end
        
        -- Teleport 5 studs above
        local success, err = pcall(function()
            hrp.CFrame = targetCFrame + Vector3.new(0, 5, 0)
        end)
        
        if success then
            print("Auto-teleported to:", selectedMachine)
        else
            warn("TP failed:", tostring(err))
            Rayfield:Notify({
                Title = "Teleport Failed",
                Content = "Check console for error",
                Duration = 1
            })
        end
    end,
})

-- Optional: Refresh button (still useful)
MiscTab:CreateButton({
    Name = "Refresh Machines List",
    Callback = function()
        local newOptions = getMachineNames()
        MachinesDropdown:Refresh(newOptions, true)
        MachinesDropdown:Set({"None"})
        Rayfield:Notify({
            Title = "Refreshed",
            Content = #newOptions .. " machines found",
            Duration = 1
        })
    end,
})


-- =====================================
-- AUTO FARM - Detects current map from workspace.Maps + Mobs from MobSpawns
-- Dropdown shows only mobs on your current island
-- =====================================
task.wait(0.5)
local FarmTab = Window:CreateTab("Auto Farm", 4483362458)

-- LocalScript (Rayfield UI - Farming Tab)

local player = game.Players.LocalPlayer
local workspace = game.Workspace

local mapsFolder    = workspace:WaitForChild("Maps")
local mobSpawnsFolder = workspace:WaitForChild("MobSpawns")

local selectedMobTypes = {}     -- table of selected mob names/types
local currentTarget    = nil    -- {obj, dist, mobType, root}

local currentMapFolder = nil
local currentMobFolder = nil

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Map Detection & Mob Type Collection
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function detectCurrentMap()
    local character = player.Character
    if not character then return nil end

    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local playerPos = root.Position
    local closestMapName = nil
    local minAvgDist = math.huge

    for _, mapFolder in mapsFolder:GetChildren() do
        if mapFolder:IsA("Folder") or mapFolder:IsA("Model") then
            local mapName = mapFolder.Name
            local mobFolder = mobSpawnsFolder:FindFirstChild(mapName)

            if mobFolder and #mobFolder:GetChildren() > 0 then
                local totalDist = 0
                local count = 0

                for _, mob in mobFolder:GetChildren() do
                    local mobRoot = (mob:IsA("Model") and mob:FindFirstChild("HumanoidRootPart")) or (mob:IsA("BasePart") and mob)
                    if mobRoot then
                        totalDist += (playerPos - mobRoot.Position).Magnitude
                        count += 1
                    end
                end

                if count > 0 then
                    local avgDist = totalDist / count
                    if avgDist < minAvgDist then
                        minAvgDist = avgDist
                        closestMapName = mapName
                        currentMapFolder = mapFolder
                        currentMobFolder = mobFolder
                    end
                end
            end
        end
    end

    return closestMapName
end

local function getMobTypes()
    if not currentMobFolder then
        return {"Scan map first"}
    end

    local types = {}
    local seen = {}

    for _, child in currentMobFolder:GetChildren() do
        local mobType

        -- Prefer attribute if present (more reliable in many games)
        if child:GetAttribute("Name") then
            mobType = tostring(child:GetAttribute("Name"))
        else
            -- Fallback: clean object name
            mobType = child.Name
                :gsub("_%d+$", "")
                :gsub("Clone", "")
                :match("^%s*(.-)%s*$")
        end

        if mobType and #mobType > 0 and not seen[mobType] then
            seen[mobType] = true
            table.insert(types, mobType)
        end
    end

    table.sort(types)
    return #types > 0 and types or {"No mobs found on this map"}
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Alive Check (stronger version from enemy code)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function isMobAlive(target)
    local part = target:IsA("Model") and target:FindFirstChildWhichIsA("BasePart", true) or target
    if not part or not part.Parent then return false end

    -- UUID check (common despawn indicator)
    if part:GetAttribute("UUID") == nil then return false end

    -- Explicit Dead flag
    if part:GetAttribute("Dead") == true then return false end

    -- Health attribute
    local health = part:GetAttribute("Health")
    if health ~= nil and health <= 0 then return false end

    -- Optional Humanoid fallback
    local humanoid = target:FindFirstChildOfClass("Humanoid") or part.Parent:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return false end

    return true
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Get alive mobs from selected types, sorted by distance
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function getAliveMobs()
    if #selectedMobTypes == 0 or (#selectedMobTypes == 1 and selectedMobTypes[1] == "None") then
        return {}
    end

    if not currentMobFolder then return {} end

    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return {} end

    local allowed = {}
    for _, t in selectedMobTypes do
        if t ~= "None" and t ~= "Scan map first" and t ~= "No mobs found on this map" then
            allowed[t] = true
        end
    end

    local aliveList = {}
    for _, obj in currentMobFolder:GetChildren() do
        local mobType = obj:GetAttribute("Name") or
            obj.Name:gsub("_%d+$", ""):gsub("Clone", ""):match("^%s*(.-)%s*$")

        if mobType and allowed[mobType] and isMobAlive(obj) then
            local rootPart = (obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart")) or
                             (obj:IsA("BasePart") and obj)

            if rootPart then
                local dist = (hrp.Position - rootPart.Position).Magnitude
                table.insert(aliveList, {
                    obj     = obj,
                    root    = rootPart,
                    dist    = dist,
                    mobType = mobType
                })
            end
        end
    end

    table.sort(aliveList, function(a,b) return a.dist < b.dist end)
    return aliveList
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Teleport helper
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function teleportToMob(hrp, mobData)
    if not hrp or not mobData or not mobData.root then return false end
    if not isMobAlive(mobData.obj) then return false end

    local offset = CFrame.new(0, 3, -5)   -- behind + above; adjust to taste
    hrp.CFrame = mobData.root.CFrame * offset
    return true
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI Elements (on your FarmTab or main Tab)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local MobDropdown = FarmTab:CreateDropdown({
    Name = "Select Mobs to Farm",
    Options = {"Scan map first"},
    CurrentOption = {"Scan map first"},
    MultipleOptions = true,
    Flag = "MobFarmSelector",

    Callback = function(selected)
        selectedMobTypes = selected
        if #selected == 0 or (#selected == 1 and (selected[1] == "None" or selected[1] == "Scan map first")) then
            currentTarget = nil
        end
    end,
})

FarmTab:CreateButton({
    Name = "ðŸ” Scan Current Map & Refresh Mobs",
    Callback = function()
        currentMapFolder = nil
        currentMobFolder = nil

        local mapName = detectCurrentMap()

        if mapName then
            local mobCount = currentMobFolder and #currentMobFolder:GetChildren() or 0
            local types = getMobTypes()
            local typesCount = #types > 0 and (#types == 1 and types[1] == "No mobs found on this map" and 0 or #types) or 0

            Rayfield:Notify({
                Title = "Map Detected",
                Content = mapName .. " (" .. mobCount .. " mobs, " .. typesCount .. " types)",
                Duration = 5
            })

            MobDropdown:Refresh(types, true)
        else
            Rayfield:Notify({
                Title = "No Map / Mobs Detected",
                Content = "Move closer to a mob spawn area",
                Duration = 6
            })
            MobDropdown:Refresh({"Scan map first"}, true)
        end
    end,
})

FarmTab:CreateToggle({
    Name = "Auto Teleport to Closest Selected Mob",
    CurrentValue = false,
    Flag = "AutoMobFarm",

    Callback = function(enabled)
        getgenv().AutoMobFarm = enabled

        if enabled then
            task.spawn(function()
                while getgenv().AutoMobFarm do
                    task.wait(0.2)

                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if not hrp then continue end

                    local aliveMobs = getAliveMobs()
                    if #aliveMobs == 0 then
                        currentTarget = nil
                        task.wait(0.8)
                        continue
                    end

                    -- Validate/update current target
                    if currentTarget and currentTarget.obj then
                        local stillAlive = false
                        for _, mob in aliveMobs do
                            if mob.obj == currentTarget.obj then
                                currentTarget = mob
                                stillAlive = true
                                break
                            end
                        end
                        if not stillAlive then
                            currentTarget = nil
                        end
                    end

                    -- Pick closest if none or invalid
                    if not currentTarget then
                        currentTarget = aliveMobs[1]
                        print("Targeting â†’", currentTarget.mobType, math.floor(currentTarget.dist), "studs")
                    end

                    if not isMobAlive(currentTarget.obj) then
                        currentTarget = nil
                        continue
                    end

                    currentTarget.dist = (hrp.Position - currentTarget.root.Position).Magnitude

                    if currentTarget.dist > 7 then
                        teleportToMob(hrp, currentTarget)
                        task.wait(0.25)
                    else
                        task.wait(0.35)  -- already in range
                    end
                end
                currentTarget = nil
            end)
        else
            currentTarget = nil
        end
    end,
})
